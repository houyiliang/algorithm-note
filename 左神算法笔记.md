#  #左神算法课

#### 异或

满足交换律和结合律

###### 交换两个数

用异或交换两个数，不用另外开辟空间

```c++
#include<iostream>
using namespace std;

void swap(int* a, int* b)
{
	*a = *a ^ *b;
	*b = *a ^ *b;
	*a = *a ^ *b;
}
int main()
{
	int a = 10, b = 20;
	swap(&a , &b);
	cout << "a = " << a << " b = " << b << endl;
	system("pause");
	return 0;
}
```

```python
a = 10
b = 20
a = a ^ b
b = a ^ b
a = a ^ b
print("a = ",a , " b = ", b)
```



###### 找数组中1-1000中唯一成对的那个数

思路：异或二者不同时结果为1   ^ ， 一些数连续的异或起来可以消除重复的数

用两次即可找到唯一重复的数

```c++
#include<iostream>
#include<ctime>
#include<random>
using namespace std;

int main()
{
	srand((int)time(NULL));		//产生一个随机种子
	int arr[1001];				//创建一个数组
	int length = sizeof(arr) / 4;	//长度等于1001
	for (int i = 0; i < length-1; i++) 
	{
		arr[i] = i + 1;
	}

	//最后一个数是随机数（也就是重复的数）1-1000
	arr[length - 1] = (rand()%1000)+1;	

	//找一个随机下标 0-1000
	int index = rand() % 1000;

	//把最后一个数和随机下标的数调换
    arr[index] = arr[length-1]^arr[index];
    arr[length-1] = arr[index]^arr[length-1];
	arr[index] = arr[index]^arr[length-1];


	for (int i = 0; i < length; i++)
	{
		cout << arr[i] <<" ";
	}
	cout << endl;
	int x1 = 0;		//0与非0数异或是本身
	for (int i = 1; i <= length - 1; i++)	//相当于把0-1000连续的异或
	{
		x1 = (x1 ^ i);
	}
	for (int i = 0; i < length; i++) 
	{
		x1 = x1 ^ arr[i];
	}
	cout << x1 << endl;
	system("pause");
	return 0;
}
```

```python
import random
#import time
arr = []                #创一个空数组
for i in range(1000):          #数组添加1-1000
    arr.append(i+1)
arr.append(random.randint(1 , 1000))  #最后一个数是随机数（重复的数）1-1000
index = random.randint(1 , 999)         #找一个随机下标
arr[len(arr) - 1] , arr[index] = arr[index] , arr[len(arr)-1]       #把最后一个数和随机下标的数调换
arr2 = list(range(1,1001))                       #创建一个1-1000的列表
x1 = 0
for i in arr2:              #将arr列表1-1000遍历异或
    print(i)
    x1 = (x1 ^ i)

for i in arr:               #遍历异或arr去除重复的数
    x1 = (x1 ^ i)
print(arr)
print("唯一重复的数为：",x1)
```



桶排序的方法

```c++
#include<iostream>
using namespace std;

int main()
{
	srand((int)time(NULL));		//产生一个随机种子
	int arr[1001];		//创建一个数组
	int length = sizeof(arr) / 4;	//长度等于1001
	for (int i = 0; i < length - 1; i++)
	{
		arr[i] = i + 1;
	}

	//最后一个数是随机数（也就是重复的数）1-1000
	arr[length - 1] = (rand() % 1000) + 1;

	//找一个随机下标 0-999
	int index = rand() % 1000;

	//把最后一个数和随机下标的数调换
	int temp;
	temp = arr[index];
	arr[index] = arr[length - 1];
	arr[length - 1] = temp;

	for (int i = 0; i < length; i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	int helper[1000] = { 0 }; //创建数组用来计数
	for (int i = 0; i < length; i++)	//用来计数
	{
		helper[arr[i]]++;
	}
	for (int i = 0; i < length; i++)		//遍历count找出出现2次数的下标
	{
		if (helper[i] == 2)
		{
			cout << i << endl;
		}
	}
	system("pause");
	return 0;
}
```

```python
import random
#import time
arr = []                #创一个空数组
for i in range(1000):          #数组添加1-1000
    arr.append(i+1)
arr.append(random.randint(1 , 1000))  #最后一个数是随机数（重复的数）1-1000
index = random.randint(1 , 999)         #找一个随机下标
arr[len(arr) - 1] , arr[index] = arr[index] , arr[len(arr)-1]       #把最后一个数和随机下标的数调换
count = [0]*1001
for i in range(0,len(arr)):      		#count 数组中存放每个数出现的次数
    count[arr[i]] = count[arr[i]]+1
for i in range(len(arr)):				#遍历count找出出现2次数的下标
    if count[i] == 2:
        print(i)
print(arr)
```

###### 数组中只有两个数是奇数个，其他的数都是偶数个

```c++
#include<iostream>
using namespace std;

void fun1(int *arr , int length)	
{
	
	int eor = 0;
	for (int i = 0; i < length; i++)	//将数组中的数连续异或
	{		
		eor ^= arr[i];			//此时eor = a ^ b  假设a和b是两个奇数个的数
	}
	int rightone = eor & (~eor + 1);	//提取出最右侧的1

	int onlyone = 0;		
	for (int i = 0; i < length; i++)		
	{
		if ((arr[i] & rightone) != 0)	//将数组中最右侧不是1的数连续异或 （a和b一定有一个在其中一方）
		{
			onlyone = onlyone ^ arr[i];			//onlyone是 a 和 b 的其中一个
		}
	}
	int otherone = (onlyone ^ eor);
	cout << onlyone << "和" << otherone << endl ;
}

int main()
{
	int arr[]= { 1,7,7,7,9,9,1,1,2,2,6,6,8,8,10,10,11,11 };
	int length = sizeof(arr) / 4;		//数组长度
	fun1(arr , length);
	system("pause");
	return 0;
}
```

```
arr=[ 5, 4, 2, 2, 3, 3, 9, 9, 7, 7]
#将数组的数连续异或结果是5^4
eor = 0
for i in range(0 , len(arr)):				#将数组中的数连续异或
    eor = eor ^ arr[i]    				#此时eor = a ^ b  假设a和b是两个奇数个的数
rightone = eor & (~eor + 1)     #提取出最右侧的1
oneof = 0
for i in range(0 , len(arr)):		
    if arr[i]&rightone != 0:		#将数组中最右侧不是1的数连续异或 （a和b一定有一个在其中一方）
        oneof = arr[i]^oneof		#oneof是 a 和 b 的其中一个		
otherone = oneof ^ eor
print("两个数分别为：",oneof , otherone)
```

#### 生成一个随机数组

```c++
#include <iostream>
#include <cstdlib> 
#include <ctime>
using namespace std;

void Random(int* a, int n, int l, int r)//生成范围在l~r的随机数 
{
	srand((unsigned int)time(0));  //设置时间种子
	for (int i = 0; i < n; i++) {
		a[i] = rand() % (r - l + 1) + l;//生成区间r~l的随机数 
	}
}

void Print(int* a, int n)
{
	for (int i = 0; i < n; i++)
		cout << a[i] << " ";
	cout << endl;
}

int main()
{
	int a[20];
	Random(a, 20, 1, 100);//生成随机数的通常范围为0~32767，这里通过取模控制取值为0~100 
	Print(a, n);
	return 0;
}

```



#### 插入排序

```c++
#include<iostream>
#include<ctime>
using namespace std;
void insert_sort(int* arr , int length)
{
	for (int i = 0; i < length; i++)	//第一个循环做到0到i都有序
	{
		int temp = arr[i];
		int j = i - 1;
		while (j >= 0 && arr[j] > temp) //j >= 0防止越界，左边的数大于右边的数交换两个数
		{
			arr[j + 1] = arr[j];
			j--;
		}
		arr[j + 1] = temp;
	}
}
int main()
{
	srand((unsigned int)time(NULL));
	int arr[20];
	for (int i = 0; i < 20; i++)	//创建一个随机的数组
	{
		arr[i] = rand() % 20;
	}
	int length = sizeof(arr) / sizeof(arr[0]);
	insert_sort(arr , length);
	for (int i = 0; i < 20; i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	system("pause");
	return 0;
}
```

```python
import random
def insert_sort(li):
    for i in range(len(li)):        #第一个循环做到0到i都有序
        tem = li[i]
        j = i - 1
        while j >= 0 and li[j] > tem:     #j >= 0防止越界，左边的数大于右边的数交换两个数
            li[j+1] = li [j]
            j -= 1
        li[j+1] = tem

li = [random.randint(0,20) for i in range(20)]      #创建一个随机的数组
insert_sort(li)
print(li)
```

#### 二分法查找

有序数组找要一个指定的数

```python
def binary_search(li:list , val:int):
    left = 0
    right = len(li)-1
    while left < right:
        mid = (left + right)//2         #向下取整 "//"取整除 - 向下取接近商的整数
        if li[mid] == val:
            return mid
        elif li[mid] > val:
            right = mid
        else:
            left = mid
    else:
        return None
#创建一个有序数组
li = list(range(0,100,1))   #range(stop)  range(start, stop ，step)默认start为0，step为1
print(binary_search(li, 79))

```

```c++
#include<iostream>
using namespace std;

int binary_search(int array[], int val)
{
	int left = 0;
	int right = 100;
	while (left <= right)
	{
		int mid = (right + left) / 2;
		if (array[mid] == val)
		{
			return mid;
			break;
		}
		else if (array[mid] > val)
		{
			right = mid - 1;
		}
		else
		{
			left = mid + 1;
		}
	}
	return -1;
}

int main()
{
	int array1[100];		
	for (int i = 0; i < 100; i++)		//创建一个有序数组
	{
		array1[i] = i;
	}
	cout << binary_search(array1, 100) << endl;
	system("pause");
	return 0;
}
```

无序数组中，相邻的数一定不相等 ，找出局部最小值。思路：二分法

```python
def local_minima(li:list):
    left = 0
    right = len(li)-1
    if (li[left] < li[left + 1]):	 #判断最左端是否为局部最小
        return li[0]
    elif (li[right] < li[right - 1]):	#判断最右端是否为局部最小
        return li[right]
    else:
        while(left <= right):			
                mid = (left + right) // 2
                if li[mid] > li[mid+1]:
                    left = mid+1
                elif li[mid] > li[mid-1]:
                    right = mid-1
                else:
                    return li[mid]

li = [6,5,10,9,3,2,7,8,9]
print(local_minima(li))
```

#### 递归求数组中最大值



master公式的使用
T(N)=a * T(N/b)+O(N^d)
1)log(b,a) > d->复杂度为O(N ^ log(b,a))
2)log(b,a) = d->复杂度为O(N ^d * logN)
3)log(b,a) < d->复杂度为O(N ^ d)

```python
import random
#递归求数组中最大值的函数
def Get_max(li:list , left , right):
    if left == right: return li[left]
    mid = left + ((right - left)>>1)
    leftmax =Get_max(li , left , mid)
    rightmax =Get_max(li , mid+1 , right)
    return max(leftmax ,rightmax)

#创建一个随机数组
li = [random.randint(0 , 20) for i in range(50)]
print(li)
print(Get_max(li , 0 , 19))
```

```c++
#include<iostream>
#include<ctime>
using namespace std;

int Get_max(int* arr , int left ,int right)
{
	if (left == right)
	{
		return arr[left];
	}
	int mid = left + ((right - left) >> 1);   //这种求中点的方式防止数组过长时溢出  >>位运算优先级很低
	int leftmax = Get_max(arr, left, mid);
	int rightmax = Get_max(arr, mid+1, right);
	return max(leftmax, rightmax);

}

int main()
{
	srand((unsigned int)time(NULL));
	int arr[20];
	for (int i = 0; i < 20; i++)
	{
		arr[i] = rand() % 20;
	}
	for (int i = 0; i < 20; i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	int left = 0;
	int right = sizeof(arr) / sizeof(arr[0])-1;
	cout << right;
	int Max = Get_max(arr, left, right);
	cout << "数组的最大值为：" << Max << endl;
	system("pause");
	return 0;
}
```



#### 归并排序

```python
import random

def merge_sort(li:list , left , right):      #用递归把列表分为两个有序列表
    if left == right:
        return
    mid = left + ((right - left)>>1)
    merge_sort(li , left , mid)
    merge_sort(li , mid+1 , right)
    merge(li , left ,mid , right)

def merge(li:list, left ,mid , right):      #将两个列表合并
    help=[0]*(right-left+1)         #开辟一个辅助列表存放两个列表合并值
    index = 0       #help 的下标
    p1 = left       #指向左边列表最左端
    p2 = mid + 1    #指向右边列表的最左端
    while p1 <= mid and p2 <= right:   #左边列表和右边列表随便一个越界即退出循环
        if li[p1] <= li[p2]:
            help[index] = li[p1]
            index += 1
            p1 += 1
        else:
            help[index] = li[p2]
            p2 += 1
            index += 1
    while p1 <= mid:
        help[index] = li[p1]
        index += 1
        p1 += 1
    while p2 <= right:
        help[index] = li[p2]
        index += 1
        p2 +=1
    for i in range (len(help)):                     #最核心的一步
        li[left + i] = help[i]

li = [random.randint(0,1000) for i in range(0,20)]
left = 0
right = len(li)-1
print(li)
merge_sort(li , left ,right)
print(li)
```



```c++
#include<iostream>
using namespace std;
 
void Merge(int arr[],int low,int mid,int high){
    //low为第1有序区的第1个元素，i指向第1个元素, mid为第1有序区的最后1个元素
    int i=low,j=mid+1,k=0; //mid+1为第2有序区第1个元素，j指向第1个元素
    int *temp=new(nothrow) int[high-low+1]; //temp数组暂存合并的有序序列
    if(!temp){ //内存分配失败
        cout<<"error";
        return;
    }
    while(i<=mid&&j<=high){
        if(arr[i]<=arr[j]) //较小的先存入temp中
            temp[k++]=arr[i++];
        else
            temp[k++]=arr[j++];
    }
    while(i<=mid)//若比较完之后，第一个有序区仍有剩余，则直接复制到t数组中
        temp[k++]=arr[i++];
    while(j<=high)//同上
        temp[k++]=arr[j++];
    for(i=low,k=0;i<=high;i++,k++)//将排好序的存回arr中low到high这区间
		arr[i]=temp[k];
    delete []temp;//删除指针，由于指向的是数组，必须用delete []
}
 
//用递归应用二路归并函数实现排序——分治法
void MergeSort(int arr[],int low,int high){
    if(low<high){
        int mid=(low+high)/2;
        MergeSort(arr,low,mid);
        MergeSort(arr,mid+1,high);
        Merge(arr,low,mid,high);
    }
}
 
int main(){
    int a[10]={5,1,9,3,7,4,8,6,2,0};
    MergeSort(a,0,9);
    for(int i=0;i<10;i++)
        cout<<a[i]<<" ";
    return 0;
}
```

###### 小和问题
在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。
例子:[1,3,4,2,5]1左边比1小的数，没有;3左边比3小的数，1;4左边比4小的数，1、3;2左边比2小的数，1;5左边比5小的数，1、3、4、2;所以小和为1+1+3+1+1+3+4+2=16

暴力解法，遍历

```python
def small_sum(li:list):
    index = 0
    smallsum = 0
    while(index < len(li)-1):
        for i in range(index+1 , len(li)):
            if li[index] < li[i]:
                smallsum += li[index]
        index += 1
    return smallsum
li = [1 ,3 , 4 ,2,5]
print(small_sum(li))
```



利用归并排序的解法

```python
#!/usr/bin/python
# -*- coding: utf-8 -*-
def small_sum(arr):
    if not arr or len(arr)<1:
        return 0
    return merge_sort(arr, 0, len(arr) - 1)

def merge_sort(arr, l, r):
    if l == r :
        return 0
    mid = l + ((r - l) >> 1)
    return merge_sort(arr, l, mid) + merge_sort(arr, mid + 1, r) + merge(arr, l, mid, r)

def merge(arr, l, m, r):
    help = []
    p1 = l
    p2 = m + 1
    res = 0
    while p1 <= m and p2 <= r :
        res += (r - p2 + 1) * arr[p1] if arr[p1] < arr[p2] else  0
        if arr[p1] < arr[p2] :
            help.append(arr[p1])
            p1 += 1
        else :
            help.append(arr[p2])
            p2 += 1

    while p1 <= m :
        help.append(arr[p1])
        p1 += 1
    while p2 <= r :
        help.append(arr[p2])
        p2 += 1
    for i in range(len(help)):
        arr[l + i] = help[i]
    return res;

#from array import array
#arr = array('b', (1, 2, 3))
arr = [1,3,4,2,5]
print(small_sum(arr))
```



```c++
#include<iostream>
#include<vector> 
using namespace std;
 
 
 
int process(vector<int>& arr, int L, int R);
int merge(vector<int>& arr, int L, int M, int R);
 
 
int smallSum(vector<int>& arr)//小和函数
{
    if (arr.empty())		//判断是否为空数组
    {
        return 0;
    }
 
    return process(arr, 0, arr.size() - 1);
}
 
int process(vector<int>& arr, int L, int R)
{
    if (L == R)
    {
        return 0;
    }
    int mid = L + ((R - L) >> 1);
 
    return process(arr, L, mid) + process(arr, mid + 1, R) + merge(arr, L, mid, R);
           //小和等于左边排好序求小和+右边排好序求小和+merge求小和的结果
}
 
int merge(vector<int>& arr,int L,int M,int R)
{
    vector<int>help;//创建一个辅助数组
    help.resize(R - L + 1);//开辟和arr一样的大小
    int i = 0, p1 = L, p2 = M + 1, res = 0;//res来接收小和 
    while (p1 <= M && p2 <= R)
    {
        res += arr[p1] < arr[p2] ? (R - p2 + 1) * arr[p1] : 0;//小和+=
        help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];//用一个临时数组来排序
    }
    while (p1 <= M)//如果右边临界了，把左边加入到辅助数组中
    {
        help[i++] = arr[p1++];
    }
    while (p2 <= R)//如果左边临界了 把右边加入到辅助数组中，上下只会中一个情况
    {
        help[i++] = arr[p2++];
    }
    for (int k = 0; k < help.size(); k++)//把临时数组倒回原数组
    {
        arr[L + k] = help[k];
    }
    return res;//返回小和
}
 
 
int main()
{
    //测试
    vector<int>v;
    v.push_back(1);
    v.push_back(3);
    v.push_back(4);
    v.push_back(2);
    v.push_back(5);
 
    cout << smallSum(v) << endl;//输出v数组的小和
    
    for (vector<int>::iterator it = v.begin(); it != v.end(); it++)//输出排好序的数组
    {
        cout << *it << " ";
    }
    cout << endl;
 
    return 0;
}
```



###### 逆序对问题

在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对。

#### 快速排序

###### 荷兰国旗问题

问题一
给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)

(1)arr[i] <= num , arr[i]和<= 区域的下一个数交换，<=区域向右扩，i++

(2)arr[i] > num , i++

相当于推着小于等于区域在走

```python

def Holland_Question(li:list , num):
    index = 0
    left = 0
    while index < len(li):
        if li[index] <= num:
            li[left] , li[index] = li[index] , li[left]  #li[i]和<= 区域的下一个数交换
            index += 1
            left += 1
        else:
            index += 1

num = 5
li = [10,8,2,3,3,2,9,7,8]
Holland_Question(li,num)
print(li)
```



问题二
给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)

（1）arr[i] < num , [i] 和 <区域下一个交换 ， < 区域向右扩 , i++

（2）arr[i] == num , i++

（3）arr[i] > num , arr[i] 和>区域前一个交换，>区域向左扩，i原地不变

```python
def Holland_Questiom(li:list , num):
    index = 0
    left = 0			#小于区域的边界
    right = len(li)-1		#大于区域的边界
    while index <= right:
        if li[index] < num:
            li[left] , li[index] = li[index] , li[left]
            left += 1
            index += 1
        elif li[index] == num:
            index+=1
        else:
            li[index] , li[right] = li[right] , li[index]
            right -= 1

num = 5
li = [5,5,4,4,2,2,3,3,2,2,7,9,4,4,8,5]
Holland_Questiom(li , num)
print(li)
```



```c++
void arrPartition(int* arr, int pivot , int length) {
	int index = 0;
	int less = 0;  //小于区域的边界
	int more = length - 1; //大于区域的边界
	while (index < more) {
		if (arr[index] < pivot) {
			swap(arr[less], arr[index]);
			less++;
		}
		else if (arr[index] == pivot) {
			index++;
		}
		else {
			swap(arr[index], arr[more]);
			more--;
		}
	}
}
```



######  快速排序

```
import random
def partition(arr, low, high):
    i = (low - 1)  # 最小元素索引
    pivot = arr[high]

    for j in range(low, high):

        # 当前元素小于或等于 pivot
        if arr[j] <= pivot:
            i = i + 1
            arr[i], arr[j] = arr[j], arr[i]

    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return (i + 1)
# 快速排序函数
def quick_sort(arr, low, high):
    if low < high:
        index = random.randint(low , high)
        arr[index] , arr[high] = arr[high] , arr[index]
        pi = partition(arr, low, high)
        quick_sort(arr, low, pi - 1)
        quick_sort(arr, pi + 1, high)

li = [random.randint(0,100) for i in range(20)]
quick_sort(li , 0 , 19)
print(li)
```



```c++
#include<iostream>
#include<ctime>
using namespace std;

void Random(int* a, int n, int l, int r)//生成范围在l~r的随机数 
{
	srand((unsigned int)time(0));  //设置时间种子
	for (int i = 0; i < n; i++) {
		a[i] = rand() % (r - l + 1) + l;//生成区间r~l的随机数 
	}
}
void Print(int* a, int n)
{
	for (int i = 0; i < n; i++)
		cout << a[i] << " ";
	cout << endl;
}
void swap(int* a, int* b)
{
	*a = *a ^ *b;
	*b = *a ^ *b;
	*a = *a ^ *b;
}
int partition(int* arr, int low, int high)
{
	int i = low - 1;
	int pivot = arr[high];
	for (int j = low; j < high; j++)
	{
		if (arr[j] <= pivot)
		{
			i++;
			swap(arr[i], arr[j]);
		}
	}
	swap(arr[i + 1], arr[high]);
	return (i + 1);
}
void quick_sort(int* arr, int low, int right)
{
	if (low < right) 
	{
		int mid = partition(arr, low, right);
		quick_sort(arr, low, mid - 1);
		quick_sort(arr, mid + 1, right);
	}
}
int main()
{
	int a[20];
	Random(a, 20, 1, 100);//生成随机数的通常范围为0~32767，这里通过取模控制取值为0~100
	quick_sort(a, 0, 19);
	Print(a, 20);
	return 0;
}
```



#### 堆

###### 推排序

大根堆父节点大于子节点

父节点  （i - 1）/2

左孩子   2i  + 1

右孩子   2i  + 2

```python
import random
def heap_insert(li:list, index):        #index 子节点的下标
    while li[index] > li[(index - 1) // 2] and index > 0:  # 比较子节点和父节点的大小 ， 若index = 0已经是根节点 那其的父节点仍是其本身
        li[index], li[(index - 1) // 2] = li[(index - 1) // 2], li[index]  # 交换子节点和父节点
        index = (index - 1) // 2    #注意（0-1）//2 = -1

def heapfiy(li , index , heapsize):
    left = index * 2 + 1        #左孩子的下标
    while left < heapsize:
        # left+1 < heapsize 防止越界
        largest = (left + 1) if (left + 1) < heapsize and li[left] < li[left + 1] else left  # 取左右孩子较大的节点
        largest = largest if li[largest] > li[index] else index         #取孩子的父亲较大的节点
        if largest == index:
            break
        li[largest] , li[index] = li[index] , li[largest]   #交换两个值
        index = largest
        left = index * 2 + 1
def heap_sort(li:list):
    if len(li) <= 1:
        return
    for i in range(len(li)):        #将列表依次插入堆
        heap_insert(li,i)
    # for i in range(len(li),-1,-1):
    #     heapfiy(li , i ,len(li))
    heapsize = len(li)
    li[0], li[heapsize-1] = li[heapsize-1], li[0]
    heapsize -= 1
    while heapsize > 0:
        heapfiy(li, 0, heapsize)
        li[0], li[heapsize - 1] = li[heapsize - 1], li[0]
        heapsize -= 1
li = [random.randint(0,100) for i in range(10)]
print(li)
heap_sort(li)
print(li)
```



```c++
#include<iostream>
#include<ctime>
using namespace std;

void Random(int* a, int n, int l, int r)//生成范围在l~r的随机数 
{
	srand((unsigned int)time(0));  //设置时间种子
	for (int i = 0; i < n; i++) {
		a[i] = rand() % (r - l + 1) + l;//生成区间r~l的随机数 
	}
}
void Print(int* a, int n)
{
	for (int i = 0; i < n; i++)
		cout << a[i] << " ";
	cout << endl;
}
void swap(int* a, int* b)
{
	*a = *a ^ *b;
	*b = *a ^ *b;
	*a = *a ^ *b;
}
void heap_insert(int* arr, int index)//index子节点下标,插入后是大根堆
{
	while (arr[index] > arr[(index - 1) / 2])
	{
		swap(arr[index], arr[(index - 1) / 2]);
		index = (index - 1) / 2;
	}
}
void heapfiy(int* arr, int index, int length)
{
	int left = index * 2 + 1;
	while (left < length) {
		int largest = arr[left + 1] > arr[left] && left + 1 < length ? left + 1: left;
		largest = arr[largest] > arr[index] ? largest : index;
		if (largest == index) {
			break;
		}
		swap(arr[largest], arr[index]);
		index = largest;
		left = index * 2 + 1;
	}
	
}
void heap_sort(int* arr,int length)
{
	if (arr == NULL && length <= 1) {
		return;
	}
	for (int i = 0; i < length; i++) {
		heap_insert(arr, i);
	}
	swap(arr[0], arr[--length]);
	while (length > 0) {
		heapfiy(arr, 0, length);
		swap(arr[0], arr[--length]);
	}
}
int main()
{
	int arr[10];
	Random(arr, 10, 1, 100);
	Print(arr, 10);
	heap_sort(arr,10);
	Print(arr, 10);
	return 0;
}
```



###### 堆排序扩展题目
已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。

自带小根堆，给它一个数弹出一个数，这种情况可以用自带的

如果是改变堆中的某个数，还要让其实现堆，这情况需要自己手写堆

```python
import heapq
def sorted_distance_lessk(li:list , k):
    hq = []
    for i in range(0,k):              #将li的前k个数添加到小根堆中
        heapq.heappush(hq , li[i])
    index = 0
    for i in range(k,len(li)):
        li[index] = heapq.heappop(hq)
        index += 1
        heapq.heappush(hq , li[i])
    while hq:       #判断是否为空
        li[index] = heapq.heappop(hq)
        index += 1
li = [5,4,2,3,3,2,7,9,4]
sorted_distance_lessk(li , 7)
print(li)

```





###### python优先队列

```python
import heapq
lst = [8,2,6,1,5,3,9,11]
#1、创建堆—heappush(heap, item)
hq = []
for i in lst:
    heapq.heappush(hq , i)
print(hq)   # [1, 2, 3, 8, 5, 6, 9, 11]   默认小根堆

# 2、弹出并返回堆中最小的元素—heapq.heappop(heap)
# 【注】在弹出最小元素后，堆队列性质保持不变。使用heap[0]可以访问最小元素而不删除它
a = heapq.heappop(hq)
print(a)    #1
print(hq)       #[2, 5, 3, 8, 11, 6, 9]

# 3、将item压入堆中，并弹出其最小元素
# —heapq.heappushpop(heap, item)
# 【注】相当于调用 heappush() 再调用 heappop() ，但是比它们更有效率

b =heapq.heappushpop(hq,0)
print(b)        #0
print(hq)       #[2, 5, 3, 8, 11, 6, 9]

# 4、将列表转换成堆—heapq.heapify(x)
heapq.heapify(lst)
print(lst)


# 5、弹出并返回 heap 中最小的一项，同时压入新的 item—heapq.heapreplace(heap, item)
# 【注】相当于调用 heappop() 再调用 heappush() ，但是比它们更有效率

c = heapq.heapreplace(hq,0)
print(c)    #2
print(hq)   #[0, 5, 3, 8, 11, 6, 9]

# 6、将多个已排序的输入合并为一个已排序的输出
# —heapq.merge(iterables, key=None, reverse=False)
# 【注】*iterables为多个已排序的输入，key为None时，直接比较元素的大小，reverse=True逆序排列

d = [0 ,1 ,3 ,5]
e = [2 ,6 ,8 ,9]
print(list(heapq.merge(d,e)))       #[0, 1, 2, 3, 5, 6, 8, 9]

# 7、返回前n个最大元素组成的列表—heapq.nlargest(n, iterable, key=None)
f = heapq.nlargest(3,hq)
print(f)

# 8、返回前n个最小元素组成的列表—heapq.nsmallest(n, iterable, key=None)
s = heapq.nsmallest(3,hq)
print(s)
```



###### C++里优先队列

使用函数对象`greater<int>`来生成小根堆

```c++
#include <queue>
priority_queue<int, vector<int>, greater<int>> test; 

```



![微信图片_20220213124126](D:\侯翊良学习资料\python学习资料\微信图片_20220213124126.png)





#### 桶排序

基数排序

```python
import random
import numpy as np
def max_bits(li:list):          #最大值有几位十进制的函数
    max_num = 0
    for i in range(0,len(li)):    #遍历列表找出最大值
        max_num = max(max_num , li[i])
    digit = 0
    while max_num != 0:
        digit += 1
        max_num //= 10
    return digit
def get_digit(x , d):      #d = 1 时取个位 ， d = 2 时取十位 ， d = 3时取百位
    return (x//int(pow(10,d-1)))%10
def radix_sort(li:list , begin , end , digit):          #digit 表示最大的数有几个十进制位
    radix = 10   #以10为基底
    bucket = [0]*(end - begin) #额外空间大小  end - begin
    for d in range(1,digit+1):        #出桶进桶多少次
        count = [0]*10              #存放0-9
        for i in range(begin,end):        #按个位数大小存放到count中 ，第二个循环按百位大小
            j = get_digit(li[i],d)
            count[j] += 1
        for i in range(1,radix):
            count[i] = count[i] + count[i - 1]
        for i in range(end-1,begin-1,-1):       #把count中数按顺序读出
            j = get_digit(li[i],d)
            bucket[(count[j]-1)]=li[i]
            count[j] -= 1
        index = 0
        for i in range(begin, end):
            li[i] = bucket[index]
            index += 1
li = [random.randint(1,100) for i in range(20)]
#random.shuffle(li)
#li = [56,10,72,77,92,74,14,62,79,41]
print(li)
radix_sort(li,0,len(li),max_bits(li))
print(li)
```





```c++
#include<iostream>
#include<vector>
#include<ctime>
#include<algorithm>
using namespace std;
//求容器中最大值
int max_bits(vector<int>& arr)  
{
	auto maxPosition = max_element(arr.begin(), arr.end());
	return *maxPosition;
}
//d=1 返回个位 ， d = 2时返回十位
int get_digit(int x, int d)
{
	int a = (x / int(pow(10, d - 1))) % 10;
	return a;
} 

void radix_sort(vector<int>& arr, int begin, int end, int digit)
{
	int radix = 10;
	int *bucket = new int[10];
	for (int d = 1; d <= digit; d++) {
		int *count = new int[10];
		for (int i = begin; i < end; i++) {
			int j = get_digit(arr[i], d);
			count[j]++;
		}
		for (int i = 1; i < radix; i++) {
			count[i] = count[i] + count[i - 1];
		}
		for (int i = end - 1; i >= begin; i--) {
			int j = get_digit(arr[i], d);
			bucket[count[j] - 1] = arr[i];
			count[j]--;
		}
		for (int i = begin ,j=0; i < end; i++ , j++) {
			arr[i] = bucket[j];
		}
		delete[] count;
	}
}
int main()
{
	srand((unsigned int)time(NULL));
	vector<int> arr;
	for (int it = 0; it < 10; it++)
	{
		arr.push_back(rand() % 100);
	}
	for (vector<int>::iterator it = arr.begin(); it != arr.end(); it++)
	{
		cout << *it << " ";
	}
	int max_num = max_bits(arr);
	radix_sort(arr, 0, 10, max_num);
	for (vector<int>::iterator it = arr.begin(); it != arr.end(); it++)
	{
		cout << *it << " ";
	}
	system("pause");
	return 0;
}
```



```python
def radix_sort(li):
    # 找出列表中最大的数，来决定循坏放桶放几次
    max_num = max(li)
    it = 0
    while 10**it <= max_num:  #max_num几位数就循坏几次
        # 10个桶，存放数字0~9
        buckets = [[] for i in range(10)]
        for i in li:
            digit = (i//(10**it))%10          #it = 0 输出个位 ， it = 1 时输出十位
            buckets[digit].append(i)            #装桶完毕
        li.clear()
        for buc in buckets:
            li.extend(buc)              #把桶中数按先入先出顺序放回到列表中
        it += 1

import random
li = list(range(100))
random.shuffle(li)
print(li)
radix_sort(li)
print(li)
```



#### 哈希表

哈希表的简单介绍
1）哈希表在使用层面上可以理解为一种集合结构
2）如果只有key，没有伴随数据value，可以使用HashSet结构(C++中叫UnOrderedSet)
3）如果既有key，又有伴随数据value，可以使用HashMap结构(C++中叫UnOrderedMap)
4）有无伴随数据，是HashMap和HashSet唯一的区别，底层的实际结构是一回事
5）使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为O(1)，但是常数时间比较大
6）放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小7）放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地
址的大小

##### unorderedset

只有key值没有value

###### !=（==相反 ）

set 中key的数量和价值必须完全相等

不相同的话返回 true ， 相同话返回flase

```c++
#include <unordered_set> 
#include <iostream> 


int main()
{
    using namespace std;

    unordered_multiset<char> c1, c2, c3;  //multiset  可以有重复的key值 set没有重复的

    c1.insert('a');
    c1.insert('b');
    c1.insert('c');
    c1.insert('c');

    c2.insert('c');
    c2.insert('c');
    c2.insert('a');
    c2.insert('d');

    c3.insert('c');
    c3.insert('c');
    c3.insert('a');
    c3.insert('b');

    cout << boolalpha;
    cout << "c1 != c2: " << (c1 != c2) << endl;
    cout << "c1 != c3: " << (c1 != c3) << endl;
    cout << "c2 != c3: " << (c2 != c3) << endl;

    if (c1 != c2) {
        cout << "不相等" << endl;
    }

    return (0);
}
```

###### swap

```c++
#include <unordered_set> 
#include <iostream> 
using namespace std;

typedef std::unordered_multiset<char> Myset;
int main()
{
    Myset c1;

    c1.insert('a');
    c1.insert('b');
    c1.insert('c');

    cout << "交换前" << endl;
    cout << "c1:" << endl;
    // display contents " [c] [b] [a]" 
    for (Myset::const_iterator it = c1.begin();
        it != c1.end(); ++it) {
        cout << *it << "  ";
    }
    cout  << endl;
    cout << "------------------" << endl;

    Myset c2;

    c2.insert('d');
    c2.insert('e');
    c2.insert('f');
    cout << "c2:" << endl;
    // display contents " [f] [e] [d]" 
    for (Myset::const_iterator it = c2.begin();
        it != c2.end(); ++it) {
        cout << *it << "  ";
    }
    cout << endl;
    cout << "------------------" << endl;
    //swap(c1, c2);     两种情况等价
    c1.swap(c2);
    cout << "交换后:" << endl;
    // display contents " [c] [b] [a]" 
    for (Myset::const_iterator it = c1.begin();
        it != c1.end(); ++it)
        std::cout << " [" << *it << "]";
    std::cout << std::endl;

    return (0);
}
```

###### 增删改

* `size();`          //返回容器中元素的数目
* `empty();`        //判断容器是否为空
* `insert(elem);`           //在容器中插入元素。
* `clear();`                    //清除所有元素
* `erase(pos);`              //删除pos迭代器所指的元素，返回下一个元素的迭代器。
* `erase(beg, end);`    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
* `erase(elem);`            //删除容器中值为elem的元素。

````c++
#include <unordered_set>
#include <iostream> 
using namespace std;


int main()
{
    unordered_set<char> b1;

    //增
    b1.insert('a');
    b1.insert('d');
    b1.insert('b');
    b1.insert('c');
    b1.insert('e');

    for (unordered_set<char>::iterator it = b1.begin(); it != b1.end();
        it++) {
        cout << *it << " ";
    }
    cout << endl;


    //删
    b1.erase(b1.begin());
    b1.erase('d');
    for (unordered_set<char>::iterator it = b1.begin(); it != b1.end();
        it++) {
        cout << *it << " ";
    }
    cout << endl;
    cout << "------------------------" << endl;


    //size();         返回容器中元素的数目
    //empty();        判断容器是否为空

    if (b1.empty()) {
        cout << "空" << endl;
    }
    else {
        cout << "b1不为空" << endl;
        cout << "b1大小为" << b1.size() << endl;
    }
    cout << "------------------------" << endl;
    b1.clear();
    for (unordered_set<char>::iterator it = b1.begin(); it != b1.end();
        it++) {
        cout << *it << " ";
    }
    cout << endl;


    return (0);
}
````

###### 查询

* `find(key);`                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();
* `count(key);`                //统计key的元素个数

```c++
#include <unordered_set>
#include<iostream>
using namespace std;

//查找和统计
void test01()
{
	unordered_set<int> s1;
	unordered_multiset<int>s2;

	s2.insert(10);
	s2.insert(10);
	s2.insert(10);
	//插入
	s1.insert(10);
	s1.insert(30);
	s1.insert(20);
	s1.insert(40);

	//查找
	unordered_set<int>::iterator pos = s1.find(30);

	if (pos != s1.end())
	{
		cout << "找到了元素 ： " << *pos << endl;
	}
	else
	{
		cout << "未找到元素" << endl;
	}

	//统计
	int num = s1.count(30);
	cout << "num = " << num << endl;
	
	int num2 = s2.count(10);
	cout << "num2 =" << num2 << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

##### unorderedmap

pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）

###### unorderedmap  构造和赋值

**功能描述：**

* 对map容器进行构造和赋值操作

**函数原型：**

**构造：**

* `unorderedmap<T1, T2> mp;`                     //map默认构造函数: 
* `unorderedmap(const unorderedmap &mp);`             //拷贝构造函数



**赋值：**

* `map& operator=(const map &mp);`    //重载等号操作符



**示例：**

```c++
#include <unordered_map>
#include<iostream>
using namespace std;

void print_map(unordered_map<int, int> &m)
{
	for (unordered_map<int, int>::iterator it = m.begin(); it != m.end(); it++) {
		cout << "key=" << it->first << "value =" << it->second << endl;
	}
	cout << "-------------------------------" << endl;
}

int main() {
	unordered_map<int, int> m; //默认构造
	m.insert(pair<int, int>(1, 10));
	m.insert(pair<int, int>(3, 30));
	m.insert(pair<int, int>(2, 20));
	print_map(m);

	unordered_map<int, int>m2(m);//拷贝构造
	print_map(m2);


	unordered_map<int, int>m3;
	m3 = m2; //赋值
	print_map(m3);

	system("pause");
	return 0;
}
```

######  unorderedmap大小和交换

**功能描述：**

* 统计map容器大小以及交换map容器

函数原型：

- `size();`          //返回容器中元素的数目
- `empty();`        //判断容器是否为空
- `swap(st);`      //交换两个集合容器



```c++
#include<iostream>
#include<unordered_map>
using namespace std;

void print_map(unordered_map<int, int>& m)
{
	for (unordered_map<int, int>::iterator it = m.begin(); it != m.end(); it++) {
		cout << "key=" << it->first << "value =" << it->second << endl;
	}
	cout << "-------------------------------" << endl;
}

void test01()
{
	unordered_map<int, int> m;
	m.insert(pair<int, int>(1, 10));
	m.insert(pair<int, int>(3, 30));
	m.insert(pair<int, int>(2, 20));
	
	if (m.empty()) {
		cout << "m为空" << endl;
	}
	else {
		cout << "m不为空" << endl;
		cout << "m的大小为：" << m.size() << endl;
	}

}

void test02()
{
	unordered_map<int, int>m1;
	m1.insert(pair<int, int>(1, 10));
	m1.insert(pair<int, int>(3, 30));
	m1.insert(pair<int, int>(2, 20));

	unordered_map<int, int>m2;
	m2.insert(pair<int, int>(4, 40));
	m2.insert(pair<int, int>(6, 60));
	m2.insert(pair<int, int>(3, 30));

	cout << "交换前" << endl;
	print_map(m1);
	print_map(m2);

	cout << "交换前" << endl;
	swap(m1, m2);
	print_map(m1);
	print_map(m2);
}

int main() {
	test01();
	test02();
	system("pause");
	return 0;
}
```

###### unorderedmap插入和删除

**功能描述：**

- unorderedmap容器进行插入数据和删除数据

**函数原型：**

- `insert(elem);`           //在容器中插入元素。
- `clear();`                    //清除所有元素
- `erase(pos);`              //删除pos迭代器所指的元素，返回下一个元素的迭代器。
- `erase(beg, end);`    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
- `erase(key);`            //删除容器中值为key的元素。



```c++
#include<iostream>
#include <unordered_map>
using namespace std;

void printMap(unordered_map<int, int>& m)
{
	for (unordered_map<int, int>::iterator it = m.begin(); it != m.end(); it++)
	{
		cout << "key = " << it->first << " value = " << it->second << endl;
	}
	cout << endl;
}

void test01()
{
	//插入
	unordered_map<int, int> m;
	//第一种插入方式
	m.insert(pair<int, int>(1, 10));
	//第二种插入方式
	m.insert(make_pair(3, 30));
	//第三种插入方式
	m.insert(unordered_map<int, int>::value_type(4, 40));
	//第四种插入方式
	m[2] = 20;
	printMap(m);

	//删除
	m.erase(m.begin());
	printMap(m);

	m.erase(3);
	printMap(m);

	//清空
	m.erase(m.begin(), m.end());
	m.clear();
	printMap(m);
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

###### unorderedmap查找和统计



**功能描述：**

- 对map容器进行查找数据以及统计数据



**函数原型：**

- `find(key);`                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();
- `count(key);`                //统计key的元素个数



```c++
#include <unordered_map>
#include<iostream>
using namespace std;

//查找和统计
void test01()
{
	unordered_map<int, int>m;
	m.insert(pair<int, int>(1, 10));
	m.insert(pair<int, int>(3, 30));
	m.insert(pair<int, int>(2, 20));

	//查找
	unordered_map<int, int>::iterator pos = m.find(3);

	if (pos != m.end())
	{
		cout << "找到了元素 key = " << (*pos).first << " value = " << (*pos).second << endl;
	}
	else
	{
		cout << "未找到元素" << endl;
	}

	//统计
	int num = m.count(3);
	cout << "num = " << num << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```



#### 有序表

有序表的简单介绍
1）有序表在使用层面上可以理解为一种集合结构
2）如果只有key，没有伴随数据value，可以使用TreeSet结构(C++中叫OrderedSet)
3）如果既有key，又有伴随数据value，可以使用TreeMap结构(C++中叫OrderedMap)
4）有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事
5）有序表和哈希表的区别是，有序表把key按照顺序组织起来，而哈希表完全不组织
5）红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同
6）放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小7）放入哈希表的东西，如果不是基础类型，必须提供比较器，内部按引用传递，内存占用是这个东西内存地址的大小
8）不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度

#### 链表

###### 单链表

```python
class ListNode(object):
    def __init__(self, item):
        self.item = item  # 节点值
        self.next = None # 下一个节点的引用


class single_list_node(object):  # 单链表
    def __init__(self, head=None):
        self.__head = head

    def is_empty(self):  # 判断列表是否为空
        return self.__head is None

    def length(self):  # 获取列表长度
        cur = self.__head  # cur初始指向头节点
        count = 0  # count表示列表的长度
        while cur is not None:
            count += 1
            cur = cur.next
        return count

    def travel(self):
        """遍历整个链表"""
        # cur初始时指向头节点
        cur = self.__head
        while cur is not None:
            # 打印节点的元素（数值）
            print(cur.item, end=",")
            cur = cur.next
        print()
    def add(self, item):  # 列表头部添加元素
        node = ListNode(item)  # 创建添加的节点
        node.next = self.__head  # 添加节点下一个地址指向头节点地址
        self.__head = node  # 再将头节点指向添加的节点

    def append(self, item):  # 在列表尾部添加节点
        node = ListNode(item)  # 创建添加的节点
        if self.is_empty():  # 判断节点是否为空
            self.__head = node  # 若为空将头节点指向添加的节点
        # 否则找到尾部，将尾节点的next指向新的节点
        else:
            cur = self.__head
            while cur.next is not None:
                cur = cur.next
            cur.next = node

    def insert(self, pos, item):  # 指定位置添加元素
        if pos <= 0:  # 相当于在列表头部插入节点
            self.add(item)
        elif pos >= self.length():  # 相当于在列表尾部插入节点
            self.append(item)
        else:
            node = ListNode(item)
            cur = self.__head  # cur 用于指向pos的前一个位置，初始位置为头节点
            count = 0  # count相当于索引
            while count < (pos - 1):
                cur = cur.next
                count += 1
            node.next = cur.next  # 将新节点的next指向插入位置的节点
            cur.next = node  # 将插入位置的前一个节点的next指向新的节点


    def remove(self , item):        #删除节点
        cur = self.__head
        pre = None          #用来存放要删除节点的上一个节点
        while cur is not None:
            if cur.item == item:
                if not pre:         #头节点时要删除的元素
                    self.__head = cur.next
                else:
                    pre.next = cur.next  #删除位置的上一个节点指向删除位置的下一个节点
                break
            else:
                pre = cur
                cur = cur.next

    def search(self , item):            #查找节点是否存在
        cur = self.__head
        while cur is not None:
            if cur.item == item:
                return True
            cur = cur.next
        return False

if __name__ =="__main__":
    li = single_list_node()
    print(li.is_empty())
    li.append(8)
    li.add(6)
    li.add(6)
    li.insert(2,9)
    li.travel()
    li.add(3)
    print("链表的长度：",li.length())
    print(li.search(5))
    li.remove(6)
    li.travel()
```

###### 双链表

```python
class Node(object):     #双向链表节点
    def __init__(self , item):
        self.item = item
        self.next = None
        self.prev = None

class Dlink_list(object):

    def __init__(self):
        self.__head = None

    def is_empty(self):         #判断列表是否为空
        return self.__head == None

    def length(self):
        cur = self.__head
        count = 0
        while cur != None:
            count += 1
            cur = cur.next
        return count

    def travel(self):
        cur = self.__head
        while cur != None:
            print(cur.item, end=" ")
            cur = cur.next
        print()

    def add(self , item):       #在头部插入
        node = Node(item)
        if self.is_empty():
            self.__head = node
        else:
            node.next = self.__head     #node.next指向原头节点
            self.__head.prev = node                #将head的头节点prev指向node
            self.__head = node          #将head指向node

    def append(self,item):
        node = Node(item)
        if self.is_empty():
            self.__head = node
        else:
            cur = self.__head
            while cur.next != None:     #注意循环条件
                cur = cur.next
            cur.next = node
            node.prev = cur

    def search(self , item):
        cur = self.__head
        while cur != None:
            if cur.item == item:
                return True
            cur = cur.next
        return False

    def insert(self , pos , item):          #指定位置插入元素
        node = Node(item)
        if pos <= 0:
            self.add(item)
        elif pos >= self.length():
            self.append(item)
        else:
            cur = self.__head
            count = 1
            while count < (pos-1):
                cur = cur.next
            node.prev = cur                         #先把待插入元素插入，再断开
            node.next = cur.next
            cur.next.prev = node
            cur.next = node

    def remove(self , item):
        cur = self.__head
        while cur != None:
            if cur.item == item:            #找到要删除的结点
                if cur == self.__head:          #判断此节点是否是头节点
                    self.__head = cur.next
                    if cur.next:        #判断链表是否只有一个结点
                        cur.next.prev = None
                else:
                    cur.prev.next = cur.next
                    if cur.next:            #判断是否存在下一个结点
                        cur.next.prev = cur.prev
                break
            else:
                cur = cur.next

if __name__ == "__main__":
    ll = Dlink_list()
    ll.add(1)
    ll.add(2)
    ll.append(3)
    ll.insert(2,4)
    ll.insert(4,5)
    ll.insert(0,6)
    print("length:", ll.length())
    ll.travel()
    print(ll.search(7))
    print(ll.search(3))
    ll.remove(1)
    print("length:" , ll.length())
    ll.travel()
```

###### 使用数组构造链表

```c++
Node *createList_array(int *a, int n){
	Node *root = new Node();
	Node *pnode = root;
	
	for (int i = 0; i < n - 1; ++i){
		root->value = a[i];//当前节点
		root->next = NULL;

		Node *p = new Node();//下一个结点
		p->value = a[i + 1];
		p->next = NULL;

		root->next = p;// 连接 当前节点 与 下一个结点
		root = root->next;
	}
	root->next = NULL;//这一句 最重要！！
	return pnode;
}

```



###### 反转单链表

方法一：头插法

```c++
#include<iostream>
using namespace std;

struct ListNode {
	int item;
	struct ListNode* next;
	ListNode(int x) : item(x), next(NULL){}
};

struct ListNode* reverselist(struct ListNode* head)
{
	ListNode* newhead = NULL;
	ListNode* node;
	while (head != NULL)
	{
		//对之前的列表做头删
		node = head;
		head = head->next;

		//对新链表做头插
		node->next = newhead;
		newhead = node;
	}
	return newhead;
}
void PrintListNode(ListNode* head)
{
	ListNode* cur = head;
	while (cur != NULL) {
		cout << cur->item << " ";
		cur = cur->next;
	}
	cout << endl;
}
void test()
{
	ListNode* n1 = new ListNode(1);
	ListNode* n2 = new ListNode(2);
	ListNode* n3 = new ListNode(3);
	ListNode* n4 = new ListNode(4);
	ListNode* n5 = new ListNode(5);

	n1->next = n2;
	n2->next = n3;
	n3->next = n4;
	n4->next = n5;
	PrintListNode(n1);
	ListNode * newhead = reverselist(n1);
	PrintListNode(newhead);
}

int main()
{
	test();
	return 0;
}

```

```python

class ListNode(object):
    def __init__(self, item):
        self.item = item  # 节点值
        self.next = None # 下一个节点的引用
def reverse_ListNode(head):
    newhead = None
    node = ListNode(object)
    while head != None:
        #对旧的链表做头删法
        node = head
        head = head.next

        #对新的链表做头插
        node.next = newhead
        newhead = node
    return newhead
def travel(head):
    """遍历整个链表"""
    # cur初始时指向头节点
    cur = head
    while cur is not None:
        # 打印节点的元素（数值）
        print(cur.item, end=",")
        cur = cur.next
    print()

n1 = ListNode(1)
n2 = ListNode(2)
n3 = ListNode(3)
n4 = ListNode(4)
n5 = ListNode(5)

n1.next = n2
n2.next = n3
n3.next = n4
n4.next = n5
travel(n1)
newhead = reverse_ListNode(n1)
travel(newhead)

```

方法二

```c++
#include<iostream>
using namespace std;


struct ListNode {
	int item; 
	struct ListNode* next;
};

struct ListNode* reverselist(struct ListNode* head)
{
	if (head == NULL) {
		//判断是否为空链表
		return NULL;
	}
	struct ListNode* p0 = NULL;
	struct ListNode* p1 = head;
	struct ListNode* p2 = head->next;
	
	while (p1 != NULL)
	{
		p1->next = p0;
		p0 = p1;
		p1 = p2;

		if (p2 != NULL) {
			p2 = p2->next;
		}
	}
	return p0;
}
```



```python
def reverse_ListNode(head):
    if head == None:
        return None
    p0 = None
    p1 = head
    p2 = head.next
    while p1 != None:
        p1.next = p0
        p0 = p1
        p1 = p2
        if p2 != None:
            p2 = p2.next
    return p0
```



###### 双链表的反转

```python
class Node(object):
    def __init__(self , item):
        self.item = item
        self.next = None
        self.pre = None

def reverse_list(head):
    pre = None
    while head != None:
        next = head.next
        head.next = pre
        head.pre = next
        pre = head
        head = next   #next = head.next 指向下一个节点
    return pre

def travel(head):
    cur = head
    while cur != None:
        print(cur.item , end=" ")
        cur = cur.next
    print()

n1 = Node(1)
n2 = Node(2)
n3 = Node(3)
n4 = Node(4)
n5 = Node(5)

n1.next = n2
n2.next = n3
n3.next = n4
n4.next = n5

n2.pre = n1
n3.pre = n2
n4.pre = n3
n5.pre = n4
travel(n1)
newhead = reverse_list(n1)
travel(newhead)

```

```c++
#include <iostream>

struct Node {
    int data;
    Node* next; // 指向下一个节点
    Node* prev; // 指向前一个节点
};

//对链表进行反转
void reverse(Node** head) {
    Node* temp = NULL;
    Node* current = *head;

    //交换每个节点的后向指针和前向指针
    // 1-->2-->3, 假设2为current.
    while (current != NULL) {
        temp = current->prev; //temp=1
        current->prev = current->next; //3-->2
        current->next = temp;            //2-->1 
        current = current->prev; //3-->2-->1, current变为3，继续往后循环。
    }
    //总结：先处理前向指针，然后处理后向指针。这些操作都只对当前节点(current),不涉及其它节点。
    //1.缓存前向指针
    //2.将后向指针赋值给前向指针
    //3.将缓存的前者指针，赋值给后向指针
    //4.当前节点指针移动到下一个待处理节点

    //修改头指针之前，先检测链表是否为空链表，或者只有一个节点的情况
    if (temp != NULL)
        *head = temp->prev;
}

// 给定链表的头指针(head)以及一个整数的头部  
// 之所以传入双指针，因为函数中需要修改链表  
void push(Node** head, int newData) {
    //1. 分配新节点内存  
    Node* newNode = new Node;

    //2. 赋值  
    newNode->data = newData;

    //3. 将原始头节点做为新节点的后向指针，而前向指针置为NULL  
    newNode->next = (*head);
    newNode->prev = NULL;

    //4. 将原始头节点的前向指针置为新的节点  
    if ((*head) != NULL)
        (*head)->prev = newNode;

    //5. 将头指针置为新的节点  
    (*head) = newNode;
}

void printList(Node* head) {
    while (head != NULL) {
        std::cout << " " << head->data << " ";
        head = head->next;
    }
    std::cout << std::endl;
}


int main() {
    //初始化链表为：10<->8<->6<->4<->2<->0
    Node* head = NULL;
    push(&head, 0);
    push(&head, 2);
    push(&head, 4);
    push(&head, 6);
    push(&head, 8);
    push(&head, 10);

    std::cout << "Original DLL is: " << std::endl;
    printList(head);

    reverse(&head);

    std::cout << "Reversed DLL is: " << std::endl;
    printList(head);
    return 0;
}
```

###### 链表打印函数

```c++
void printlist(Node* head) {
	while (head != NULL) {
		cout << head->item << " ";
		head = head->next;
	}
	cout << endl;
}
```

```python
def travel(self):
        """遍历整个链表"""
        # cur初始时指向头节点
        cur = self.__head
        while cur is not None:
            # 打印节点的元素（数值）
            print(cur.item, end=",")
            cur = cur.next
        print()
```



###### 链表从尾部添加函数

```c++
void push(Node** head, int newData) {
	Node* newnode = new Node;	//1、分配新节点内存

	newnode->item = newData;	//赋值

	newnode->next = *head;

	*head = newnode;		//将头指针置为新的节点
}
```



```python
def append(self, item):  # 在列表尾部添加节点
        node = ListNode(item)  # 创建添加的节点
        if self.is_empty():  # 判断节点是否为空
            self.__head = node  # 若为空将头节点指向添加的节点
        # 否则找到尾部，将尾节点的next指向新的节点
        else:
            cur = self.__head
            while cur.next is not None:
                cur = cur.next
            cur.next = node
```



###### 打印两个有序列表的公共部分

给定两个有序链表的头指针head1和head2，打印两个链表的公共部分。

```c++
#include<iostream>
using namespace std;

struct Node {
	int item;
	Node* next;
};

void push(Node** head, int newData) {
	Node* newnode = new Node;	//1、分配新节点内存

	newnode->item = newData;	//赋值

	newnode->next = *head;

	*head = newnode;		//将头指针置为新的节点
}

void printlist(Node* head) {
	while (head != NULL) {
		cout << head->item << " ";
		head = head->next;
	}
	cout << endl;
}

void printcommon(struct Node* head1 , struct Node * head2) {
	while (head1 != NULL && head2 != NULL) {
		if (head1->item > head2->item) {//谁小谁移动
			head2 = head2->next;
		}
		else if (head1->item < head2->item) {
			head1 = head1->next;
		}
		else {//相等的话打印 ， 共同移动
			cout << head1->item << " ";
			head1 = head1->next;
			head2 = head2->next;
		}
	}
	cout << endl;
}

int main()
{
	Node* head = NULL;
	push(&head, 6);
	push(&head, 5);
	push(&head, 4);
	push(&head, 4);
	push(&head, 4);
	push(&head, 1); 
	printlist(head);
	Node* head2 = NULL;
	push(&head2, 9);
	push(&head2, 8);
	push(&head2, 7);
	push(&head2, 6);
	push(&head2, 4);
	push(&head2, 4);
	printlist(head2);

	printcommon(head, head2);
	return 0;
}
```

```python
class Node(object):
    def __init__(self , item):
        self.item = item
        self.next = None

#打印链表
def travel(head):       
    cur = head
    while cur != None:
        print(cur.item , end=" ")
        cur = cur.next
    print()     
    
#链表尾部添加数
def append(head , item):
    node = Node(item)
    cur = head
    while cur.next is not None:
        cur = cur.next
    cur.next = node
    
#打印两个链表公共的部分
def print_commom(head1 :Node , head2:Node):
    while head1 != None and head2 != None:
        if head1.item < head2.item:
            head1 = head1.next
        elif head1.item > head2.item:
            head2 = head2.next
        else:
            print(head1.item , end= " ")
            head1 = head1.next
            head2 = head2.next
    print()

n1 = Node(1)
append(n1 , 3)
append(n1 , 4)
append(n1 , 5)
append(n1 , 6)
append(n1 , 7)

n2 = Node(2)
append(n2 , 3)
append(n2 , 4)
append(n2 , 5)
append(n2 , 6)
append(n2 , 7)

travel(n1)
travel(n2)
print_commom(n1 ,n2)
```

###### 判断一个链表是否为回文结构

方法一：线性表+双指针

时间复杂度O(N) , 空间复杂度O(N)

思路：先遍历一遍链表储存在一个数组中，然后利用双指针判断前后值是否相等

```c++
#include<iostream>
#include<vector>
using namespace std;

struct ListNode {
	int item;
	ListNode* next;
};
bool isPail(ListNode* head) {
	if (head == NULL) {
		return false;
	}
	if (head->next == NULL) {
		return true;
	}
	vector<int> list;		//用来储存链表
	while (head != NULL) {
		list.push_back(head->item);
		head = head->next;
	}
	//双指针，一个指向起点一个指向终点
	int left = 0, right = list.size() - 1;
	while (left < right) {
		if (list[left] != list[right]) {
			return false;
		}
		left++;
		right--;
	}
	return true;
}
void push(struct ListNode** head, int new_item) {
	ListNode* newnode = new ListNode;	//分配新节点内存
	newnode->item = new_item;	//赋值
	newnode->next = *head; //插入新节点指向原来的头结点
	*head = newnode;	//更新头节点
}
int main()
{
	ListNode* head = NULL;
	push(&head, 1);
	push(&head, 2);
	push(&head, 3);
	push(&head, 3);
	push(&head, 2);
	push(&head, 1);
	int result =  isPail(head);
	cout << result << endl;
	return 0;
}
```

```python
class ListNode(object):
    def __init__(self , item):
        self.item = item
        self.next = None

def is_palindrome(head):
    if head == None:
        return False
    if head.next ==None:
        return True
    list = []
    while head != None:
        list.append(head.item)
        head = head.next
    left = 0
    right = len(list) - 1
    while left < right:
        if list[left] != list[right]:
            return False
        left += 1
        right -= 1
    return True

def append(head , item):
    node = ListNode(item)
    cur = head
    while cur.next is not None:
        cur = cur.next
    cur.next = node

n1 = ListNode(1)
append(n1 , 2)
append(n1 , 3)
append(n1 , 2)
append(n1 , 1)
print(is_palindrome(n1))
```

方法二：利用栈的先进后出

将整个链表进栈出栈，出栈后相当于反转链表，判断是否相等

时间复杂度：O(N)

空间复杂度：O(N)

```c++
bool IsPalindrom(ListNode* head) {
	if (head == NULL || head->next == NULL) {
		return true;
	}
	ListNode* temp = head;
	stack<int> s; //创建栈
	 //将节点依次放入栈
	while (temp != NULL) {
		s.push(temp->item);
		temp = temp->next;
	}
	//栈中数据依次弹出和链表比较
	while (head != NULL) {
		if (s.top() != head->item) {
			return false;
		}
		head = head->next;
		s.pop();
	}
	return true;
}
```

```python
from collections import deque
class ListNode(object):
    def __init__(self , item):
        self.item = item
        self.next = None

def append(head , item):
    node = ListNode(item)
    cur = head
    while cur.next is not None:
        cur = cur.next
    cur.next = node

def is_palindrome(head):
    if head == None or head.next == None:
        return True
    stack = deque()     #创建一个栈
    temp = head
    while temp != None:
        stack.append(temp.item)
        temp = temp.next
    while head != None:
        if stack.pop() != head.item:
            return False
        head = head.next
    return True

n1 = ListNode(1)
append(n1 , 2)
append(n1 , 3)
append(n1 , 2)
append(n1 , 1)
print(is_palindrome(n1))
```

方法三：找中点 + 反转链表 + 遍历比较

```c++
#include<iostream>
#include<stack>
using namespace std;
struct ListNode {
	int item;
	ListNode* next;
};
void push(struct ListNode** head, int new_item) {
	ListNode* newnode = new ListNode;	//分配新节点内存
	newnode->item = new_item;	//赋值
	newnode->next = *head; //插入新节点指向原来的头结点
	*head = newnode;	//更新头节点
}
bool is_palindrom(ListNode* head) {
	if (head == NULL || head->next == NULL) { 
		return true;
	}
	//慢指针
	ListNode* slow = head;
	//快指针
	ListNode* fast = head;
	while (fast->next != NULL && fast->next->next) {
		fast = fast->next->next;
		slow = slow->next;
	}
	fast = slow->next;		//此时fast为后半段的头结点
	slow->next = NULL;
	ListNode* newHead = NULL;
	//反转后半段链表
	while (fast != NULL) {
		//头删
		newHead = fast->next;	
		fast->next = slow; //原头结点指向中间结点
		//头插
		slow = fast;
		fast = newHead;
	}
	newHead = slow;		//后半段反转后链表的头结点
	fast = head;	//原链表的头结点
	//遍历链表是否为回文
	while (fast != NULL && newHead != NULL) {
		if (fast->item != newHead->item) {
			return false;
		}
		fast = fast->next;
		newHead = newHead->next;
	}
	return true;
}
int main()
{
	ListNode* head = NULL;
	push(&head, 1);
	push(&head, 2);
	push(&head, 3);
	push(&head, 3);
	push(&head, 2);
	push(&head, 1);
	int result = is_palindrom(head);
	cout << result << endl;
	return 0;
}
```



```python
def is_palindrome(head):
    #判断是否为空 或 长度为 1
    if head == None or head.next ==None:
        return True
    #慢指针
    slow = head
    #快指针
    fast = head
    while fast.next != None and fast.next.next != None:
        fast = fast.next.next
        slow = slow.next
    fast = slow.next   #fast为后半段的头结点
    slow.next = None
    newhead = None
    while fast != None:
        #头删
        newhead = fast.next
        fast.next = slow
        #头插
        slow = fast
        fast = newhead
    newhead = slow #后半段反转后链表的头结点
    fast = head  #原链表的头结点
    while fast != None and newhead != None:
        if fast.item != newhead.item:
            return False
        fast = fast.next
        newhead = newhead.next
    return True
```



###### 将单向链表按某值划分成左边小、 中间相等、 右边大的形式  

【题目】给定一个单链表的头节点head，节点的值类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于pivot的节点，中间部分都是值等于pivot的节点，右部分都是值大于pivot的节点。

方法一：将链表放入一个数组，调整数组中结点的顺序，将数组中结点从头到尾连接成单链表

方法二：

1、设三个引用，分别为small , equal , big

2、遍历一遍链表，分别找到第一个小于value,等于value ， 大于value的结点

3、再次遍历一遍链表，将剩余分别满足小于value，等于value，大于value的结点，放入small , equal , big区域

4、将small ， equal ， big 重新连接

```c++
#include<iostream>
using namespace std;

struct ListNode {
	int item;
	struct ListNode* next;
};
ListNode* list_partition(ListNode* head, int pivot) {
	ListNode* sh = NULL;  //small head
	ListNode* st = NULL;  //small tail
	ListNode* eh = NULL;  //equal head
	ListNode* et = NULL;  //equal tail
	ListNode* bh = NULL;  //big head
	ListNode* bt = NULL;  //big tail
	ListNode* q = NULL;
	while (head != NULL)		//尾插法
	{
		q = head->next;
		head->next = NULL;
		if (head->item < pivot) {
			if (sh == NULL) {	//如果此时大于 pivot的链表为空
				sh = head;		//保留头部位置
				st = sh;		//此时只有一个结点，即是头结点也是尾结点
			}
			else
			{
				st->next = head;	//在small链表尾部插入
				st = head;			//更新尾部结点
			}
		}
		else if (head->item == pivot) {
			if (eh == NULL) {
				eh = head;
				et = eh;
			}
			else {
				et->next = head;
				et = head;
			}
		}
		else {
			if (bh == NULL) {
				bh = head;
				bt = bh;
			}
			else {
				bt->next = head;
				bt = head;
			}
		}
		head = q;
	}		//大于 ， 小于 ， 等于三个链表划分成功
	if (st != NULL) {	//小于区域链表有结点
		st->next = eh;	//小于尾连接等于的头
		et = et == NULL ? st : et;  //再判断等于区域是否有结点
	}
	if (et != NULL) {	//等于区域链表有结点
		et->next = bh;	//等于尾连接大于的头
	}
	//返回值：如果小于头结点不是空则返回小于的头结点
	//若小于的头结点为空则返回等于的头结点
	//若等于的头结点也为空则返回大于的头结点
	return sh != NULL ? sh : eh != NULL ? eh : bh;
}
//打印函数
void printlist(ListNode * head) {
	ListNode* cur = head;
	while (cur != NULL) {
		cout << cur->item << " ";
		cur = cur->next;
	}
	cout << endl;
}
//尾部添加函数
void push(ListNode** head, int newData) {
	ListNode* newnode = new ListNode;	//1、分配新节点内存

	newnode->item = newData;	//赋值

	newnode->next = *head;

	*head = newnode;		//将头指针置为新的节点
}
int main()
{
	ListNode* head = NULL;
	push(&head, 4);
	push(&head, 7);
	push(&head, 9);
	push(&head, 2);
	push(&head, 3);
	push(&head, 3);
	push(&head, 2);
	push(&head, 4);
	push(&head, 5);
	printlist(head);
	head = list_partition(head, 4);
	printlist(head);
	system("pause");
	return 0;
}
```





###### 复制含有随机指针节点的链表

【题目】一种特殊的单链表节点类描述如下
classNode{
		int     value;
		Node  next;
		Node  rand;
		Node  ( int  val )  {  value = val ; }
	}
rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null。给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。
【要求】时间复杂度O(N)，额外空间复杂度O(1)



方法一：利用哈希表map

思路：由于复制节点的random指向的结点和原结点一样，那么我们可以使得原结点和复制节点一一映射，然后根据原结点的random确定复制节点的random（这就需要使用哈希表，一一映射）

```c++
#include<iostream>
#include<unordered_map>
using namespace std;

struct RandomListNode {
	int item;
	struct RandomListNode* next, * random;
	RandomListNode(int x) :
		item(x), next(NULL), random(NULL) {}
};

class Solution {
public:
	RandomListNode* Clone(RandomListNode* head) {
		if (head == NULL) {
			return NULL;
		}
		unordered_map<RandomListNode*, RandomListNode* > Node;		//创建一个无序的map
		RandomListNode* cur = head;
		//将链表的拷贝到哈希表中 key是新链表，value是克隆的链表
		while (cur != NULL) {
			RandomListNode* temp = new RandomListNode(cur->item); //克隆结点
			Node[cur] = temp;		//克隆结点挂到map上
			cur = cur->next;
		}
		cur = head;
		while (cur != NULL) {
			Node[cur]->next = Node[cur->next];		//Node[cur]对应的是cur的克隆结点 
			Node[cur]->random = Node[cur->random];
			cur = cur->next;
		}
		return Node[head];
	}
};
```



```python
class RandomListNode(object):
    def __init__(self , item , next , random):
        self.item = item
        self.next = next
        self.random = random

def Clone(head:RandomListNode):
    if head == None:
        return head
    cur = head
    dic = {}    # 在这个字典里，key是旧链表的节点，val是新链表的节点。
    while cur != None:
        cloneNode = RandomListNode(cur.item , None , None)
        dic[cur] = cloneNode
        cur = cur.next
    cur = head
    while cur:  # 这里用dict.get因为key值如果为空的话，就会返回默认值None
        dic.get(cur).next = dic.get(cur.next)# 根据字典的映射关系来处理新链表的random和next关系。
        dic.get(cur).random = dic.get(cur.random)
    return dic[head]        # head的val是head的复制节点（即新节点的头结点）
```

方法二：

思路：将原链表的下一个结点新建一个拷贝结点

```c++
#include<iostream>
using namespace std;

struct RandomListNode {
	int item;
	struct RandomListNode* next, * random;
	RandomListNode(int x):
		item(x) , next(NULL) , random(NULL){}
};

void printlist(RandomListNode* head) {
	while (head != NULL) {
		cout << head->item << " ";
		cout <<"随机指针后的值" << head->random->item << " ";
		head = head->next;
	}
	cout << endl;
}

RandomListNode* Clone(RandomListNode* head) {
	if (head == NULL) {
		return NULL;
	}
	RandomListNode* cur = head;
	RandomListNode* next = NULL;
	// 1->2
	//1->1~->2->2~
	while (cur != NULL) { //复制每一个结点
		next = cur->next;
		cur->next = new RandomListNode(cur->item);	//将复制结点放到原结点的下一个
		cur->next->next = next;
		cur = next;
	}
	cur = head;
	RandomListNode* curcopy = NULL;
	//set copy node random 复制随机结点
	while (cur != NULL) {  //1对1对的遍历 1 和 1~
		next = cur->next->next;  // 第一次循环此时是2
		curcopy = cur->next;  // 第一次循环此时是1~
		curcopy->random = cur->random != NULL ? cur->random->next : NULL;
		cur = next;
	}
	RandomListNode* res = head->next;	//拷贝结点的头指针
	cur = head;
	//split   分离 （太妙了）
	while (cur != NULL) {  
		next = cur->next->next;
		curcopy = cur->next;
		cur->next = next;
		curcopy->next = cur->next != NULL ? next->next : NULL;
		cur = next;
	}
	return res;
}

int main() {
	RandomListNode* n1 = new RandomListNode(1);
	RandomListNode* n2 = new RandomListNode(2);
	RandomListNode* n3 = new RandomListNode(3);

	n1->next = n2;
	n2->next = n3;

	n1->random = n3;
	n2->random = n1;
	n3->random = n2;
	printlist(n1);
	RandomListNode * head = Clone(n1);
	printlist(head);
	return 0;	 
}
```

```python
class RandomListNode(object):
    def __init__(self , item):
        self.item = item
        self.next = None
        self.random = None

def Clone(head):
    if head == None:
        return None
    cur = head
    next = None
    #复制每一个结点连到原结点的下一个
    while cur != None:
        next = cur.next
        cur.next = RandomListNode(cur.item)
        cur.next.next = next
        cur = next
    cur = head
    curcopy = None
    #复制随机结点
    while cur != None:
        next = cur.next.next
        curcopy = cur.next
        curcopy.random = cur.random.next if cur.random != None else None
        cur = next
    res = head.next
    cur = head
    while cur != None:
        next = cur.next.next
        curcopy = cur.next
        cur.next = next
        curcopy.next = next.next if cur.next != None else None
        cur = next
    return res
```

###### 两个单链表相交

【题目】给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回null
【要求】如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。

思路：

1、先判断两个链表有无环，如果有环求出入环点

2、如果两链表均无环则有以下两种情况

![img](https://img2020.cnblogs.com/blog/2024073/202201/2024073-20220119231357364-1776295525.png)

先分别求出两个链表的尾节点，如果不同则不相交。如果相同则设两指针分别指向两链表头节点，长链表的指针先走长度之差步，然后两链表指针同时走，直至相遇，此时指针所指节点即为第一个相遇节点。

3、如果两链表均有环则有以下三种情况

![img](https://img2020.cnblogs.com/blog/2024073/202201/2024073-20220119231221460-1071143871.png)

若两链表入环点相同即情况2，则类似与两无环链表情况。计算两链表到入环点的长度之差，长链表的指针先走长度之差步，然后两链表指针同时走，直至相遇，此时指针所指节点即为第一个相遇节点。

若两链表入环节点不同则可能有情况1和情况3。从其中一个链表的入环点开始走，若走完一圈还没碰到另一个链表的入环点则情况1，不相交；若在走完一圈之前碰到了另一个链表的入环点，则为情况3，此时两个入环点均可以是第一个相遇点。

4、如果一个有环一个无环，则必不相交

```c++
#include<iostream>
#include<cmath>
using namespace std;

struct ListNode {
	int item;
	ListNode* next;
	ListNode(int x):
		item(x) , next(NULL){}
};

//找出第一个环结点
ListNode* GetLoopNode(ListNode* head) {
	if (head == NULL || head->next == NULL || head->next->next == NULL) {
		return NULL;
	}
	ListNode* slow = head->next;	//慢指针走一步，直接定位到一步后的起点，快指针同理
	ListNode* fast = head->next->next; //快指针走两步
	while(slow != fast){	//如果是环链表快慢指针一定会相遇
		if (slow->next == NULL || fast->next == NULL) {
			return NULL;
		}
		slow = slow->next;
		fast = fast->next->next;
	}
	//相遇后，把快指针移到头结点
	//调整为一次走一步
	//和慢指针一起移动，最后在第一个入环结点相遇（别问为什么）
	fast = head;
	while (fast != slow) {
		fast = fast->next;
		slow = slow->next;
	}
	return fast;
}

//两链表均无环的情况
ListNode* NoLoopNode(ListNode* head1, ListNode* head2) {
	if (head1 == NULL || head2 == NULL) {
		return NULL;
	}
	ListNode* cur1 = head1;
	ListNode* cur2 = head2;
	int LengthDifference = 0; //记录两链表的长度差
	while (cur1->next != NULL) {
		LengthDifference++;
		cur1 = cur1->next;
	}
	while (cur2->next != NULL) {
		LengthDifference--;
        cur2 = cur2->next;
	}
	if (cur1 != cur2) { //尾结点不相等即不相等
		return NULL;
	}
	cur1 = LengthDifference > 0 ? head1 : head2; //cur1指向长链表的头
	cur2 = cur1 == head1 ? head2 : head1;		//cur2 短链表头
	LengthDifference = abs(LengthDifference);
	while (LengthDifference != 0){		//长链表先走差值
		LengthDifference--;
		cur1 = cur1->next;
	}
	while (cur1 != cur2) {  //两链表同时走直至相遇
		cur1 = cur1->next;
		cur2 = cur2->next;
	}
	return cur1;

}

//两个有环链表的情况
ListNode* LoopNode(ListNode* head1, ListNode* loop1, ListNode* head2, ListNode* loop2) {
	ListNode* cur1 = NULL;
	ListNode* cur2 = NULL;
	if (loop1 == loop2) {    //入环点相同，与两无环链表方法类似
		cur1 = head1;
		cur2 = head2;
		int LengthDifference = 0;
		while (cur1 != loop1) {
			LengthDifference++;
			cur1 = cur1->next;
		}
		while (cur2 != loop2) {
			LengthDifference--;
			cur2 = cur2->next;
		}
		cur1 = LengthDifference > 0 ? head1 : head2;
		cur2 = cur1 == head1 ? head2 : head1;
		LengthDifference = abs(LengthDifference);
		while (LengthDifference != 0){
			cur1 = cur1->next;
			LengthDifference--;
		}
		while (cur1 != cur2) {
			cur1 = cur1->next;
			cur2 = cur2->next;
		}
		return cur1;
	}
	else {	//入环点不同，从一个环节点开始
		cur1 = loop1->next;
		while (cur1 != loop1) {
			if (cur1 == loop2) {
				return loop1;
			}
			cur1 = cur1->next;
		}
		return NULL;
	}
}

//求第一个相交结点， 没有返回null
ListNode* GetFirstInteresectNode(ListNode* head1, ListNode* head2) {
	if (head1 == NULL || head2 == NULL) {		
		return NULL;
	}
	ListNode * loop1 = GetLoopNode(head1);	//链表1的入环点
	ListNode * loop2 = GetLoopNode(head2);
	if (loop1 == NULL && loop2 == NULL) {		//情况1
		return NoLoopNode(head1, head2);
	}
	if (loop1 != NULL && loop2 != NULL) {		//情况3
		return LoopNode(head1, loop1, head2, loop2);
	}
	return NULL;				//情况2
}

int main() {
	ListNode* n1 = new ListNode(1);
	ListNode* n2 = new ListNode(2);
	ListNode* n3 = new ListNode(3);
	ListNode* n4 = new ListNode(4);
	n1->next = n2;
	n2->next = n3;
	n3->next = n4;
	n4->next = n2;
	ListNode* n5 = new ListNode(5);
	ListNode* n6 = new ListNode(6);
	n5->next = n6;
	n6->next = n2;
	ListNode* result = GetFirstInteresectNode(n1, n5);
	cout << result->item << endl;
	return 0;
}
```



```python
class ListNode(object):
    def __init__(self , item):
        self.item = item
        self.next = None

#找出第一个环节点
def get_loop_node(head):
    if head ==None or head.next == None or head.next.next ==None:
        return None
    slow = head.next
    fast = head.next.next
    while slow != fast:
        if slow.next == None or fast.next == None:
            return None
        slow = slow.next
        fast = fast.next.next
    fast = head
    while slow != fast:
        fast = fast.next
        slow = slow.next
    return fast

#两链表均无环的情况
def no_loop_node(head1 , head2):
    if head1 == None or head2 ==None:
        return None
    cur1 = head1
    cur2 = head2
    length_difference = 0
    while cur1.next != None:
        length_difference += 1
        cur1 = cur1.next
    while cur2.next != None:
        length_difference -= 1
        cur2 = cur2.next
    if cur1 != cur2:
        return None
    else:
        cur1 = head1 if length_difference > 0 else head2
        cur2 = head2 if cur1 == head1 else head1
        length_difference = abs(length_difference)
        while length_difference != 0:
            cur1 = cur1.next
            length_difference -= 1
        while cur1 != cur2:
            cur1 = cur1.next
            cur2 = cur2.next
    return cur1

#两链表均有环的情况
def loop_node(head1 , loop1 , head2 , loop2):
    cur1 = None
    cur2 = None
    if loop1 == loop2:
        cur1 = head1
        cur2 = head2
        length_difference = 0
        while cur1 != loop1:
            length_difference += 1
            cur1 = cur1.next
        while cur2 != loop2:
            length_difference -= 1
            cur2 = cur2.next
        cur1 = head1 if length_difference > 0 else head2
        cur2 = head2 if cur1 == head1 else head1
        length_difference = abs(length_difference)
        while length_difference != 0:
            length_difference -= 1
            cur1 = cur1.next
        while cur1 != cur2:
            cur1 = cur1.next
            cur2 = cur2.next
        return cur1
    else:
        cur1 = loop1.next
        while cur1 != loop1:
            if cur1 == loop2:
                return loop1
            cur1 = cur1.next
        return None

#两链表第一个相交点
def get_first_interesect_node(head1 , head2):
    if head1 == None or head2 ==None:
        return None
    loop1 = get_loop_node(head1)
    loop2 = get_loop_node(head2)
    if loop1 == None and loop2 == None:
        return no_loop_node(head1 , head2)
    if loop1 != None and loop2 != None:
        return loop_node(head1 , loop1 , head2 , loop2)
    return None

if __name__ == "__main__":
    n1 = ListNode(1)
    n2 = ListNode(2)
    n3 = ListNode(3)
    n4 = ListNode(4)
    n5 = ListNode(5)
    n6 = ListNode(6)
    n7 = ListNode(7)
    n1.next = n2
    n2.next = n3
    n3.next = n4
    n4.next = n5
    n5.next = n6
    n6.next = n7
    n7.next = n4
    n8 = ListNode(8)
    n9 = ListNode(9)
    n8.next = n9
    n9.next = n3
    result = get_first_interesect_node(n1 , n8)
    print(result.item)
```

#### 二叉树

###### 定义结构

```c++
/*定义二叉树的结构*/
typedef struct Node
{
    char data;                    /*数据域*/
    struct Node* lchild, * rchild; /*左子树和右子树*/
} *BiTree, BiNode;
/*整棵树和结点名称*/
```



###### 创建二叉树

```c++
//递归创建二叉树
void CreateBiTree(BiTree& T)
{
    char ch;
    cin >> ch;
    if (ch == '#')
        T = NULL;
    else
    {
        T = new BiNode; /*创建一个新节点*/
        T->data = ch;
        CreateBiTree(T->lchild);
        CreateBiTree(T->rchild);
    }
    /*递归创建*/
}
```

###### 遍历

用递归实现

![image-20220224123036869](C:\Users\houyiliang\AppData\Roaming\Typora\typora-user-images\image-20220224123036869.png)

先序遍历

```c++
void PreOrderTraverse(BiTree T)
{
    /*先序遍历*/
    if (T)
    {
        cout << T->data;
        PreOrderTraverse(T->lchild);
        PreOrderTraverse(T->rchild);
    }
}
```

中序遍历

```c++
void InOrderTraverse(BiTree T)
{
    /*中序遍历*/
    if (T)
    {
        InOrderTraverse(T->lchild);
        cout << T->data;
        InOrderTraverse(T->rchild);
    }
}
```

后序遍历

```c++
void PostOrderTraverse(BiTree T)
{
    /*后序遍历*/
    if (T)
    {
        PostOrderTraverse(T->lchild);
        PostOrderTraverse(T->rchild);
        cout << T->data;
    }
}
```



用非递归实现

先序遍历（头左右）

1、从栈中弹出一个节点cur

2、处理（打印）cur

3、先右后左（如果右子树的话）

4、循环这个过程

![image-20220224151546940](C:\Users\houyiliang\AppData\Roaming\Typora\typora-user-images\image-20220224151546940.png)

```c++
void PreOrderTraverse(BiTree head)
{
    if (head != NULL) {
        stack<BiTree> s;
        s.push(head);
        while (!s.empty())
        {
            head = s.top();
            s.pop();
            cout << head->data;
            if (head->rchild != NULL) { //先右后左
                s.push(head->rchild);
            }
            if (head->lchild != NULL) {
                s.push(head->lchild);
            }
        }
    }
    cout << endl;
}
```

后序遍历（左右头）

1、从栈中弹出一个结点

2、弹出结点依次放入另一个栈

3、先左后右  ：（头右左）刚好是后序的相反，所以再利用一个栈实现反转

4、循坏

5、出栈

![image-20220224162813984](C:\Users\houyiliang\AppData\Roaming\Typora\typora-user-images\image-20220224162813984.png)



```c++
void post_order_traverse(BiTree head) {
    if (head != NULL) {
        stack<BiTree> s1;
        stack<BiTree> s2;
        s1.push(head);
        while (!s1.empty()) {
            head = s1.top();    //弹出结点放入辅助栈
            s1.pop();
            s2.push(head);
            if (head->lchild != NULL) {
                s1.push(head->lchild);
            }
            if (head->rchild != NULL) {
                s1.push(head->rchild);
            }
        }
        while (!s2.empty()) {
            cout << s2.top()->data << " ,";
            s2.pop();
        }
    }
    cout << endl;
}
```

中序遍历（左头右）

1、每棵子树的左边界压到栈里，依次弹出结点过程中，打印

2、对弹出结点的右树周而复始

![image-20220224170921059](C:\Users\houyiliang\AppData\Roaming\Typora\typora-user-images\image-20220224170921059.png)

```C++
void in_order_traverse(BiTree head) {
    if (head != NULL) {
        stack<BiTree> s;
        //栈为空是整棵树的边界条件 head为空是子树左边界的边界条件
        while (!s.empty() || head != NULL) { 
            if (head != NULL) {
                s.push(head);
                head = head->lchild; //每棵子树的左边界压到栈里
            }
            else {
                head = s.top();
                s.pop();
                cout << head->data << " ";
                head = head->rchild;	//把每个右结点当作头新的头结点周而复始
            }
        }
    }
    cout << endl;
}
```



###### 直观的打印二叉树

```c++
#include<string>
string get_space(int num) {
    string result = " ";
    for (int i = 0; i < num; i++) {
        result.append(" "); //追加字符或字符串
    }
    return result;
}

void print_binary_tree(BiTree head , int height , string to , int len) {
    if (head == NULL) {
        return;
    }
    print_binary_tree(head->rchild, height + 1, "v", len);
    string val = to + (head->data) + to;
    int lenM = val.length();
    int lenL = (len - lenM) / 2;
    int lenR = len - lenM - lenL;
    val = get_space(lenL) + val + get_space(lenR);
    cout << (get_space(height * len) + val) << "\n";
    print_binary_tree(head->lchild, height + 1, "^", len);
}

int main()
{
    BiTree T;
    cout << "先序遍历输入(以#结束)：";
    CreateBiTree(T);
    print_binary_tree(T, 0, "H", 17);
    return 0;
}
```

